---
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import BarChart from '../../components/newSvelte/charts/BarChart.svelte';
import { getPluginDataArray } from '../../utils/data';

// const repoData = await getRepoData();

// const repoDataWithRepos = repoData.filter(x => x.repo !== undefined) as PluginRepoDataNonNull[];

// const totalPluginCount = repoDataWithRepos.length;

// const packageManagerInfo = groupBy(repoDataWithRepos, x => x.repo.packageManager ?? 'undefined');
// const packageManagerChartInfo = Object.entries(packageManagerInfo)
// 	.map(([key, value]) => {
// 		if (key === 'undefined') {
// 			key = 'No Lockfile found';
// 		}
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);

// const installedBundlersInfo = multiGroupBy(repoDataWithRepos, x => {
// 	return x.repo.installedBundlers;
// });
// const installedBundlersChartInfo = Object.entries(installedBundlersInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);

// const installedTestingFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
// 	return x.repo.installedTestingFrameworks;
// });

// const installedTestingFrameworksChartInfo = Object.entries(installedTestingFrameworksInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);
// const noTestingFrameworkCount = repoDataWithRepos.filter(x => x.repo.installedTestingFrameworks.length === 0).length;

// const frontendFrameworks = ['react', 'preact', 'svelte', 'vue', '@angular/core', 'solid-js'];
// const installedFrontendFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
// 	return arrayIntersect([...x.repo.dependencies, ...x.repo.devDependencies], frontendFrameworks);
// });

// const installedFrontendFrameworksChartInfo = Object.entries(installedFrontendFrameworksInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);

// const noFrontendFrameworkCount = repoDataWithRepos.filter(
// 	x => arrayIntersect([...x.repo.dependencies, ...x.repo.devDependencies], frontendFrameworks).length === 0,
// ).length;

// const installedToolingFrameworksInfo = multiGroupBy(repoDataWithRepos, x => {
// 	const allDeps = [...x.repo.dependencies, ...x.repo.devDependencies];
// 	const result = new Set<string>();

// 	if (allDeps.some(x => x.includes('eslint'))) {
// 		result.add('eslint');
// 	}

// 	if (allDeps.some(x => x.includes('prettier'))) {
// 		result.add('prettier');
// 	}

// 	if (allDeps.some(x => x.includes('@biomejs'))) {
// 		result.add('biome');
// 	}

// 	if (allDeps.some(x => x.includes('dprint'))) {
// 		result.add('dprint');
// 	}

// 	if (x.repo.usesTypescript) {
// 		result.add('typescript');
// 	}

// 	return Array.from(result);
// });

// const installedToolingFrameworksChartInfo = Object.entries(installedToolingFrameworksInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);

// const mostUsedDepsInfo = multiGroupBy(repoDataWithRepos, x => {
// 	return [...x.repo.dependencies, ...x.repo.devDependencies];
// });

// const mostUsedDepsChartInfo = Object.entries(mostUsedDepsInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => b.value - a.value);

// const limitedMostUsedDepsChartInfo = mostUsedDepsChartInfo.filter(x => x.value / totalPluginCount >= 0.01);

// const hasBetaManifestInfo = groupBy(repoDataWithRepos, x => x.repo.hasBetaManifest.toString());
// const hasBetaManifestChartInfo = Object.entries(hasBetaManifestInfo)
// 	.map(([key, value]) => {
// 		return {
// 			label: key,
// 			value: value.length,
// 		};
// 	})
// 	.sort((a, b) => a.label.length - b.label.length);

const frontendFrameworks = ['react', 'preact', 'svelte', 'vue', '@angular/core', 'solid-js'];
const tooling = ['eslint', 'prettier', '@biomejs', 'dprint', 'typescript'];

const data = await getPluginDataArray();
const view = data.view();

const dataPoints = view.repo_data_points(data);

const frontEndFrameworksDataPoints = dataPoints.dependencies.filter(x => frontendFrameworks.includes(x.name));
const toolingDataPoints = dataPoints.dependencies.filter(x => tooling.includes(x.name));

const mostUsedDependencies = dataPoints.dependencies.filter(x => x.value >= 1);
mostUsedDependencies.sort((a, b) => b.value - a.value);
---

<StarlightPage
	frontmatter={{
		title: 'Repository Data',
		description: `Data extracted from the repositories of Plugins.`,
	}}
	headings={[
		// { depth: 2, text: 'Dependencies', slug: 'dependencies' },
		{ depth: 3, text: 'Package Manager Usage', slug: 'package-manager-usage' },
		{ depth: 3, text: 'Code Bundler Usage', slug: 'code-bundler-usage' },
		{ depth: 3, text: 'Developer Tooling Usage', slug: 'developer-tooling-usage' },
		{ depth: 3, text: 'Testing Framework Usage', slug: 'testing-framework-usage' },
		{ depth: 3, text: 'Frontend Framework Usage', slug: 'frontend-framework-usage' },
		{ depth: 3, text: 'Most Used Dependencies', slug: 'most-used-dependencies' },
	]}
>
	<!-- <p><strong>Beta Manifest</strong>: {dataPoints.beta_manifest.toFixed(1)}% of plugins have a BRAT beta manifest.</p> -->

	<!-- <h2 id="dependencies">Dependencies</h2> -->

	<h3 id="package-manager-usage">Package Manager Usage</h3>

	<p>The distribution of package managers used in plugins. The package manager is determined by the presence of a lockfile in the plugin repository.</p>

	<p><BarChart dataPoints={dataPoints.package_managers} xLabel="Package Managers" yLabel="Percent of Plugins" yDomain={[0, 100]} client:only="svelte" /></p>

	<p>
		{dataPoints.no_package_managers.toFixed(1)}% of plugins have no lockfile.
	</p>

	<h3 id="code-bundler-usage">Code Bundler Usage</h3>

	<p>
		The distribution of code bundlers used in plugins. The bundler is determined by the presence of dependencies in the plugins <code>package.json</code>.
	</p>

	<p><BarChart dataPoints={dataPoints.bundlers} xLabel="Code Bundlers" yLabel="Percent of Plugins" yDomain={[0, 100]} client:only="svelte" /></p>

	<p>
		{dataPoints.no_bundlers.toFixed(1)}% of plugins use no code bundler.
	</p>

	<h3 id="developer-tooling-usage">Developer Tooling Usage</h3>

	<p>The distribution of developer tooling used in plugins.</p>

	<p><BarChart dataPoints={toolingDataPoints} xLabel="Tooling Dependencies" yLabel="Percent of Plugins" yDomain={[0, 100]} client:only="svelte" /></p>

	<h3 id="testing-framework-usage">Testing Framework Usage</h3>

	<p>
		The distribution of testing frameworks used in plugins. The testing frameworks usage is determined by the presence of dependencies in the plugins <code
			>package.json</code
		>.
	</p>

	<p><BarChart dataPoints={dataPoints.testing_frameworks} xLabel="Testing Frameworks" yLabel="Percent of Plugins" yDomain={[0, 100]} client:only="svelte" /></p>

	<p>
		{dataPoints.no_testing_frameworks.toFixed(1)}% of plugins use no testing framework.
	</p>

	<h3 id="frontend-framework-usage">Frontend Framework Usage</h3>

	<p>
		The distribution of frontend frameworks used in plugins. The frontend frameworks usage is determined by the presence of dependencies in the plugins <code
			>package.json</code
		>.
	</p>

	<p><BarChart dataPoints={frontEndFrameworksDataPoints} xLabel="Frontend Frameworks" yLabel="Percent of Plugins" yDomain={[0, 100]} client:only="svelte" /></p>

	<h3 id="most-used-dependencies">Most Used Dependencies</h3>

	<p>This table shows direct dependencies of all plugins, sorted by how many plugins use them. Dependencies with less than one percent usage are not shown.</p>

	<table>
		<thead>
			<tr>
				<th> Name</th>
				<th> Usage Percentage</th>
			</tr>
		</thead>
		<tbody>
			{
				mostUsedDependencies.map(x => (
					<tr>
						<td>{x.name}</td>
						<td>{x.value.toFixed(1)}%</td>
					</tr>
				))
			}
		</tbody>
	</table>
</StarlightPage>
